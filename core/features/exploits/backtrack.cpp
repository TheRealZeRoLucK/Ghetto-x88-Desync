#include "backtrack.h"

std::deque<stored_records> records[65];
backtracks backtrack;

float backtracks::lerp_time() noexcept {
	int ud_rate = interfaces::console->get_convar("cl_updaterate")->get_int();
	convar* min_ud_rate = interfaces::console->get_convar("sv_minupdaterate");
	convar* max_ud_rate = interfaces::console->get_convar("sv_maxupdaterate");

	if (min_ud_rate && max_ud_rate)
		ud_rate = max_ud_rate->get_int();

	float ratio = interfaces::console->get_convar("cl_interp_ratio")->get_float();

	if (ratio == 0)
		ratio = 1.0f;

	float lerp = interfaces::console->get_convar("cl_interp")->get_float();
	convar* c_min_ratio = interfaces::console->get_convar("sv_client_min_interp_ratio");
	convar* c_max_ratio = interfaces::console->get_convar("sv_client_max_interp_ratio");
	auto ratiod = std::clamp(ratio, c_min_ratio->get_float(), c_max_ratio->get_float());
	return std::max(interfaces::console->get_convar("cl_interp")->get_float(), (ratiod / ((min_ud_rate->get_float()) ? max_ud_rate->get_float() : ud_rate)));

	//return std::max(lerp->getFloat(), (ratio / ((max_ud_rate) ? max_ud_rate->getFloat() : ud_rate->getFloat())));
}

vec3_t extrapolate(player_t* his, int value) {
	return his->origin() + (his->velocity() * (interfaces::globals->interval_per_tick * (float)value));
}

float extra_ticks() noexcept
{
	auto network = interfaces::engine->get_net_channel_info_alt();
	if (!network)
		return 0.f;

	return std::clamp(network->get_latency(1) - network->get_latency(0), 0.f, interfaces::console->get_convar("sv_maxunlag")->get_float());
}

bool backtracks::is_tick_valid(float simulation_time, float max_time) noexcept {
	i_net_channel_info* net_channel = interfaces::engine->get_net_channel_info_alt();

	if (!net_channel)
		return false;

	float correct = 0;
	correct += net_channel->get_latency(0);
	correct += net_channel->get_latency(1);
	correct += lerp_time();
	std::clamp(correct, 0.f, interfaces::console->get_convar("sv_maxunlag")->get_float());
	float delta_time = correct - (ticks_to_time(csgo::local_player->get_tick_base()) - simulation_time);
	float latecy = variables::fakelatency;
	float time_limit = variables::fakelatency_enable ? latecy : 0.2f;

#pragma region EXPERIMENTAL
	//float ping = variables::fakelatency_enable ? latecy : 0.2f;
#pragma endregion

	std::clamp(time_limit, 0.001f, 0.4f);
	return fabsf(delta_time) <= time_limit;
}
// changed 2's to 4's
bool backtracks::valid_tick(float simtime) {
	auto network = interfaces::engine->get_net_channel_info_alt()->get_latency(0);
	if (!network)
		return false;

	auto delta = std::clamp(network + lerp_time(), 0.f, interfaces::console->get_convar("sv_maxunlag")->get_float()) - (interfaces::globals->cur_time - simtime);
	return std::fabsf(delta) <= 0.4f;
}

void backtracks::update() noexcept {
	auto local_player = reinterpret_cast<player_t*>(interfaces::entity_list->get_client_entity(interfaces::engine->get_local_player()));
	if (!variables::backtrack_alt || !local_player || !local_player->is_alive()) {
		if (!records->empty())
			records->clear();

		return;
	}

	for (int i = 1; i <= interfaces::globals->max_clients; i++) {
		auto entity = reinterpret_cast<player_t*>(interfaces::entity_list->get_client_entity(i));
		if (!entity || entity == local_player || entity->dormant() || !entity->is_alive() || !entity->is_enemy()) {
			records[i].clear();
			continue;
		}

		if (records[i].size() && (records[i].front().simulation_time == entity->simulation_time()))
			continue;

		auto var_map = reinterpret_cast<std::uint32_t>(entity) + 0x24;
		auto vars_count = *reinterpret_cast<int*>(static_cast<std::uint32_t>(var_map) + 0x14);
		for (int j = 0; j < vars_count; j++)
			*reinterpret_cast<std::uint32_t*>(*reinterpret_cast<std::uint32_t*>(var_map) + j * 0xC) = 0;

		stored_records record{ };
		record.head = local_player->get_hitbox_position(hitbox_head);
		record.simulation_time = entity->simulation_time();

		entity->setup_bones(record.matrix, 128, 0x7FF00, interfaces::globals->cur_time);

		records[i].push_front(record);

		while (records[i].size() > 3 && records[i].size() > static_cast<size_t>(time_to_ticks(static_cast<float>(variables::backtrack_time) / 1000.f + extra_ticks())))
			records[i].pop_back();

		if (auto invalid = std::find_if(std::cbegin(records[i]), std::cend(records[i]), [](const stored_records& rec) { return !backtrack.valid_tick(rec.simulation_time); }); invalid != std::cend(records[i]))
			records[i].erase(invalid, std::cend(records[i]));
	}
}

void backtracks::backtrack_run(c_usercmd* cmd) noexcept {
	if (!variables::backtrack_alt)
		return;

	if (!csgo::local_player || !csgo::local_player->is_alive())
		return;

	if (variables::fakelatency_enable && (variables::backtrack_time <= 200)) {
		variables::backtrack_time += variables::fakelatency;
	}

	auto local_player = csgo::local_player;
	auto wpn = csgo::local_player->active_weapon();
	if (!wpn)
		return;
	auto best_fov{ 255.f };
	auto best_dist{ FLT_MAX };
	player_t* best_target{ };
	int besst_target_index{ };
	vec3_t best_target_head_position{ };
	int best_record{ };
	vec3_t dog;
	for (int i = 1; i <= interfaces::globals->max_clients; i++) {
		auto entity = reinterpret_cast<player_t*>(interfaces::entity_list->get_client_entity(i));
		if (!entity || entity == local_player || entity->dormant() || !entity->is_alive()
			|| entity->team() == csgo::local_player->team())
			continue;
		auto head_position = entity->get_hitbox_position(hitbox_head) - local_player->get_eye_pos();
		math::vector_angles(head_position, dog);
		math::normalize3(dog);
		dog.clamp();
		float current_dist = csgo::local_player->origin().distance_to(head_position);
		auto fov = math::get_fov(cmd->viewangles + (csgo::local_player->aim_punch_angle() * 2.f), dog);
		if (fov < best_fov) {
			best_fov = fov;
			best_target = entity;
			best_dist = current_dist;
			besst_target_index = i;
			best_target_head_position = head_position;
		}
	}
	vec3_t angle;
	if (best_target) {
		if (records[besst_target_index].size() <= 3)
			return;

		best_fov = 255.f;
		best_dist = 999.f;
		for (size_t i = 0; i < records[besst_target_index].size(); i++) {
			auto record = &records[besst_target_index][i];
			if (!record || !is_tick_valid(record->simulation_time, 0.2f))
				continue;
			auto headposition = record->head - local_player->get_eye_pos();
			math::vector_angles(headposition, angle);
			math::normalize3(angle);
			angle.clamp();
			float current_dist = csgo::local_player->origin().distance_to(record->head);
			auto fov = math::get_fov(cmd->viewangles + (csgo::local_player->aim_punch_angle() * 2.f), angle);
			if (fov < best_fov) {
				best_fov = fov;
				best_dist = current_dist;
				best_record = i;
			}
			float real_target_time = record->simulation_time;
			int tisa = cmd->tick_count;
			cmd->tick_count = time_to_ticks((real_target_time + lerp_time()));
		}
	}
	if (best_record && cmd->buttons & in_attack)
		cmd->tick_count = time_to_ticks(records[besst_target_index][best_record].simulation_time + lerp_time());
}