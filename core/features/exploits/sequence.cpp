#include "../features.hpp"

float sequence::get_estimated_server_time(float latency)
{
	return csgo::local_player->get_tick_base() *(uintptr_t)&interfaces::globals->interval_per_tick;
}

void sequence::update_incoming_sequences(i_net_channel* net_channel) {
#pragma region EXPERIMENTAL
	int time_limit = variables::backtrack_time;
	if (time_limit <= 200) {
		time_limit = 0;
	}
	else {
		time_limit = 200;
	}

	if (!variables::fakelatency_enable || time_limit == 0)
		return; 
#pragma endregion

	if (!csgo::local_player)
		return;

	if (!net_channel)
		return;

	if (net_channel->in_sequence_nr > last_incoming_sequence) {
		last_incoming_sequence = net_channel->in_sequence_nr;
		auto newincomingsequence = sequence_object_t();
		newincomingsequence.iInReliableState = net_channel->in_reliable_state;
		newincomingsequence.iOutReliableState = net_channel->out_reliable_state;
		newincomingsequence.iSequenceNr = net_channel->in_sequence_nr;
		newincomingsequence.flCurrentTime = interfaces::globals->realtime;
		sequences_vector.push_front(newincomingsequence);
	}

	if (sequences_vector.size() > 2048)
		sequences_vector.pop_back();
}

void sequence::clear_incoming_sequences() {
	if (!sequences_vector.empty()) {
		last_incoming_sequence = 0;
		sequences_vector.clear();
	}
}

void sequence::add_latency_to_net_channel(i_net_channel* net_channel, float latency) {
	for (auto& sequence : sequences_vector) {
		if (interfaces::globals->realtime - sequence.flCurrentTime >= latency) {
			net_channel->in_reliable_state = sequence.iInReliableState;
			net_channel->in_sequence_nr = sequence.iSequenceNr;
			break;
		}
	}
}
